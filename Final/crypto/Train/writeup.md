# Train

> Author: howard41436 | 楊皓丞 | B06902097

### Solution

看到這題很快就想到CBC的padding orcale attack，雖然這題沒有padding，但padding oracle attack的精髓在於只要oracle會去解密並且判斷格式是否正確，就可以仿造類似的手法做攻擊。本題中，解密完server會執行一行`date, session, secret = plain.split(b'|')`，這行指令在明文中沒有剛好兩個`'|'`時會噴錯，因此印出except內的訊息，這可以讓我們使用padding oracle attack。本題中16個byte為一個block，因此在還原最後一塊明文時需要改變的是倒數第二塊密文，要注意這塊的明文中原本含有一個`'|'`，所以在改變此塊密文時，理論上這塊解密完就會變成亂碼，因此解密完整個明文中除了最後一塊前面應該剩下一個`'|'`，不過當我們枚舉到最後一塊的最後一個字元變成`'|'`時，明文中就會有兩個`'|'`，得到正確的訊息。此時就能由CBC的性值知道明文最後一個字元的值。同理可以還原出整個最後一塊明文。

但要特別注意的是，亂碼中的256個字元，裏頭剛好含有`'|'`的機率其實很高，因此剛剛的算法很可能失敗。不過，藉由先送一次拿掉最後一塊的密文去解密，我們可以判別亂碼中沒有`'|'`和有一個`'|'`的情況(事實上有超過一個`'|'`的情況無法和沒有`'|'`的情況分辨，但超過一個的機率低很多，先不考慮)。因此上述算法變成去判斷加了最後一塊回去後，回傳訊息是否會改變。為了再進一步提升機率，我一次是進行兩個連線，然後把結果取聯集，但我後來發現其實這跟同一份code多跑幾次沒什麼差。

總之，因為我們的每個字元是獨立搜的，所以成功率只是影響整個流程的快慢，終究會全部搜到，搜完之後發現最後一個block是`CNEVERGetSoLD}`，數一數前面的字元數後發現，整個flag的長相會是`FLAG{xxCNEVERGetSoLD}`，只剩兩個未知字元，因次我也不想搜倒數第二塊了，直接用語意判斷第一個詞應為`CBC`，試過`cb`的四種大小寫組合中有一組就是對的了。使用的程式碼`sol.py`附在`code/`資料夾中。